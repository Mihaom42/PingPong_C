<h1> Pong game implementation in C++ </h1>

<h2> 1. Game overview </h2>

При запуске приложения, инициализируется окно с двумя платформами, шаром посередине и 2 стенками. Платформой можно управлять нажатием клавиши `W`.
и `S`. Мяч автоматически начинает двигаться. При ударе мяча о стену, или платформу, он отталкивается и ускоряется.

<h2> 2. OOP </h2>
    Все операции инкапсулированы в классы и соответствующие функции-члены; состояние контролируется через элементы данных соответствующих классов.
    
    Я использовал наследование между базовым классом PongObject и его конкретными дочерними элементами Paddle, Ball и Bot, как будет описано ниже.
    
    Базовый конструктор переопределяется в обоих дочерних классах соответствующим образом; Я не видел необходимости в каком-либо дальнейшем применении полиморфизма (поскольку это игра, а не пользовательская программа, нет пользователя, который хотел бы, например, вызвать функцию иначе, чем я это сделал в реализации). Кроме того, PongObject не реализован как абстрактный класс, поскольку большая часть предоставляемых им функций может быть передана (наследована) его дочерним классам. Поэтому я не использовал виртуальные функции или шаблоны.

<h2> 3. External lib </h2>

    Для отрисовки была подключена библиотека SDL2

<h2> 4. STL containers </h2>
    
    - Описание использования shared_ptr:
    Ball, Paddle и Bot инициализируются в куче. shared_ptrs, указывающий на их адреса в памяти, включаются в качестве членов класса Game. Таким образом, деструкторы для этих классов не были сочтены необходимыми, поскольку shared_ptrs выходят за пределы области действия main(), когда приложение завершает работу, и тем самым освобождают память, выделенную для объектов Ball, Paddle и Bot.

<h2> 5. App structure and implementation logic </h2>
Приложение реализовано с помощью ООП. Операции разбиты на отдельные классы с эффективной структурой наследования.

- __class `PongObject` (PongObject.h):__
    - Базовый класс для всех движущихся объектов в игре (`Paddle`, `Bot` и `Ball`).
    - Имплементирован базовый к-тор.
    - Инкапсулированы `windowLimit (x and y)`, `position (x and y)`, `length`, `thickness`, `color` и `drawingObject`.
    - Объявлены и определены `getter` и `setter`.
    - Protected ф-ции `updateDrawingObject` и `switchColor`

- __class `Paddle` (Paddle.h):__
    - Класс наследник `PongObject`
    - Определён метод `changePaddlePosition`. Метод отвечает за отслеживание позиции платформы и его отрисовки.

- __class `Ball` (Ball.h):__
    - Класс наследник `PongObject`
    - Определён метод `updatePosition`. Метод отслеживает движения мяч `getRoundWinner` отслеживает кто забил мяч.

- __class `Bot` (Bot.h):__
    - Класс наследник `PongObject`
    - Определён метод `changePaddlePosition`. Метод отвечает за отслеживание позиции платформы и его отрисовки.
    
- __class `Game` (Game.h):__

    - _public methods:_
        - `Initialize()`: Инициализация `SDL` графических объектов.
        - `GameLoop()`: вызывает методы `ProcessInput()`, `UpdateGame()` и `GenerateOutput()`. 
        - `ShutDownGame()`: уничтожает раннее созданные `SDL` объекты и завершает `SDL` сессию.

    - 'Game Loop' имплементирован следующим образом:
        - `ProcessInput()` - отвечает за обработку инпутов игрока
        - `UpdateGame()`:
        - Отвечает за обновление состояния игры на каждой итерации игрового цикла.
        - Вычисляет `deltaTime` - время, прошедшее с момента последнего цикла, а также ограничивает его, чтобы в случае паузы в игре не происходило "прыжков".
        - обновляет положение платформы, вызывая `Paddle::changePaddlePosition()`, который принимает входные данные для состояния клавиатуры, соответствующего клавише `Вверх' (W)` и `Вниз " клавиша (S)` и `deltaTime`
        - обновляет положение мяча, вызывая Ball::updatePosition(), который принимает deltaTime в качестве входных данных, а также другие соответствующие параметры.
        - проверяет, покинул ли мяч игровую зону - если да, добавляет очки победителю и сбрасывает состояние мяча в центр (а также указывает через элемент данных, что цвет мяча должен быть изменен)
        - обновляет объекты рисования `SDL` в `Paddle` , `Ball` и 'Bot'.
        - `GenerateOutput()`:
        - Отвечает за обновление графики на основе обновленного состояния игры.
        - Перерисовывает фон, стены, платформы и мяч на каждой итерации игрового цикла.
        - Если была указана необходимость перекраски шара, переключает цвет шара с помощью `Ball::switchColor()` (унаследованного от `PongObject`) и ставит приложение на паузу на 2 секунды.

<h2> 6. Pattern </h2>

    SOLID: 

    1. Single Responsibility principle
        Каждый имеющийся класс решает только одну задачу. Например класс `Paddle`, данный класс отвечает исключительно за ф-ционирование платформы. Тоже самое касается классов 'Ball' и 'Bot'. 

        Класс Game отвечает, как уже было выше описано, за процесс самой игры. Обрабатывает инпуты, пересылает информацию про положение объектов и т.д.

    2. Open-closed principle
        Классы PongObject и Game открыты для расширения, но закрыты для модицикации.

    3. Liskov substitution principle
    Все наследники PongObject являются взаимозаменяемы с родителем.
